//объект роботrobot = {	wheelD: 5.6,      // диаметр колес робота	track: 17.5,      // колея (между колес)	cpr: 360,	      // cpr "в виртуалке". На моторе 585 (274 или 385)	v: 80	          // мощность моторов}// длина клеткиcell_len = 17.5 * 3//для удобства вызова делаем обозначенияmL	=	brick.motor('M4').setPower   // левый моторmR	=	brick.motor('M3').setPower   // правый мотор//eL	=	brick.encoder('E4').read	 // левый энкодер//eR	=	brick.encoder('E3').read 	 // правый энкодерeL	=	brick.encoder('E4').readRawData	 // левый энкодер "сырые данные"eR	=	brick.encoder('E3').readRawData // правый энкодер "сырые данные"sF	=	brick.sensor('D1').read	 // сенсор спереди (УЗ)sL	=	brick.sensor('A1').read	 // сенсор левый (ИК)sR	=	brick.sensor('A2').read	 // сенсор правый (ИК)pi 	=	Math.PIabs =	Math.abswait = script.wait/*distance = 52.5 						// в смpath = (distance / (pi * robot.wheelD)) * robot.cpr	// в cprmL(robot.v)				// мощность левого мотораmR(robot.v)				// мощность правого мотораwhile (eL() < path) {			// пока энкодер_левый < пути	wait(10)}mL(0)mR(0)*/// перевод из см в crpfunction cm2cpr (cm) {return (cm / (pi * robot.wheelD)) * robot.cpr }// перевод из градусов в crpfunction deg2cpr (deg) {return (robot.track * abs(deg)) / (robot.wheelD * 360) * robot.cpr }// знак числаfunction sing(num) { return num > 0 ? 1 : -1}// управление моторами// если не определен первый (и второй) параметр, то берем значение из описания робота// если не определен второй параметр, то делаем его равным первому// если есть оба параметра, то присваиваем ихfunction motors(vL, vR){	vL = vL == undefined ? robot.v : vL	vR = vR == undefined ? vL : vR	mL(vL)	mR(vR)}// проезд прямо без сброса энкодеровfunction move(cm){	var path = cm2cpr(cm) + eL()	var sgn = sing(cm)	motors(80 * sgn, 80 * sgn)	// движение вперед	if (sgn == 1)		{		    while (eL() < path) { wait(10) }					}	// движение назад		else		{		    print(path)			    while (eL() > path) { wait(10) }					}	motors(0)}// поворот на заданный уголfunction turn(ang){	move(17.5/2)	var path = deg2cpr(ang)	var sgn = sing(ang)	motors(40 * sgn, - 40 * sgn)		// поворот по часовой стрелке	if (sgn == 1)		{	    path += eL() 			    while (eL() < path) { wait(10) }					}	// поворот против часовой стрелки		else		{	    path += eR() 			    print(path)			    while (eR() < path) { wait(10) }					}	motors(0)	move(-17.5/2)		}// плавное движениеfunction moveSmooth (cm, v)	{    v = v == undefined ? robot.v : v   // мощность моторов    var path0 = eL()		           // текущие значения энкодера (ТЗЭ)    var path = cm2cpr(cm) + path0      // конечное значение энкодера (КЗЭ)    var v0 = 30, vM = v0		       // начальная мощность моторов    var startStop = path / 4	       // длина разгона/торможения (ДРТ)    var dV = (v - v0)/10		       // дискретность разгона/торможения	while (eL() < path)		{		if (eL() < path0 + startStop)			{			vM += dV			}		else			{			if (eL() > eL() + startStop * 3)				{				vM -= dV				}			}		// скорость не становится меньше минимальной и больше максимальной			vM = vM > v ? v : vM		vM = vM < v0 ? v0: vM		motors(vM)			wait(10)			}	}// калибровка перед каждым запуском для гироскопа//brick.gyroscope().calibrate(2000)//script.wait(3000)// функция поворота на абсолютный угол по гироскопуfunction turnGyro(ang)	{	var sgn = sing(ang)		// если значение угла в градусах		if (ang < 200)		{		ang *= 1000 	// переводим в миллиградусы		}	if (sgn == 1)			{		motors(40, - 40)		}	else		{		motors(-40, 40)		}	while(abs(ang - brick.gyroscope().read()[6]) > 3000)		{		print(brick.gyroscope().read()[6])		wait(10)		}	motors(0)	}// проезд прямо без сброса энкодеров с П-регуляторомfunction move1(cm){	var path = cm2cpr(cm) + eL()	var sgn = sing(cm)	var Kp = 1.5	motors(80 * sgn, 80 * sgn)	// движение вперед	if (sgn == 1)		{		    while (eL() < path) 			{ 			var err = eL() - eR()			var u = err * Kp			motors(60 - u, 60 + u)				wait(10)				}					}	// движение назад		else		{		    print(path)			    while (eL() > path)			{ 			var err = eL() - eR()			var u = err * Kp			motors(-60 - u, -60 + u)				wait(10)				}				}	motors(0)}